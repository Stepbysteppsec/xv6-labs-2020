# proc code comment

swtch(&c->context, &p->context);语句进行上下文切换，将CPU的执行权交给这个进程。在这个进程放弃CPU使用权之前，CPU将一直运行这个进程的代码
当这个进程重新进入调度器（例如因为发生了中断或者系统调用），它应该已经改变了自己的状态（例如将状态改为SLEEPING或者RUNNABLE）。然后调度器将CPU的当前进程设置为0，表示当前没有进程在运行。
found变量用于记录在遍历所有进程后是否找到了一个可以运行的进程。如果找到了，就将其设为1；否则保持为0。

volatile是一个C/C++编程语言中的关键字，它用于修饰变量，表示该变量可能会被多个线程或外部硬件操作所更改，而这些修改可能不会被编译器所知。当使用volatile关键字修饰一个变量时，编译器会禁止对这个变量进行优化，确保每次访问这个变量时都会从内存中读取它的最新值，而不是使用寄存器或缓存中的副本。

# volatile关键字主要用于以下几种场景：

多线程环境下，多个线程访问同一个变量，其中一个线程可能修改变量的值。
对于一些特殊的硬件寄存器，如输入/输出端口或者内存映射的硬件设备，直接对这些内存地址进行操作时，需要防止编译器对其进行优化。
中断处理程序中，全局变量在主程序和中断处理之间共享，volatile可以确保正确的同步。
注意：volatile关键字不能保证原子性和互斥访问，如果需要在多线程环境下确保数据的安全访问，请使用其他同步机制，例如互斥锁（mutex）或信号量（semaphore）。

综上所述，asm volatile("wfi"); 这行代码的作用是在没有找到可运行的进程时，使用“等待中断”指令让处理器进入低功耗模式，等待中断信号。这样做能够有效地降低处理器在空闲时的能耗。

##allocproc

需要获取该资源的锁，以防止其他线程同时修改它。在获取锁之后进行操作，然后在持有锁的情况下返回给调用方，以确保该资源只会被一个线程修改

##为什么用kalloc()来初始化trapframe?
trapframe结构体保存了进程在被中断时的处理器状态。这包括所有的寄存器值，PC（程序计数器）值等。每个进程都需要有自己的trapframe，因为在中断发生时，这些值会被压入栈中，以便在中断处理完毕后恢复原来的处理器状态。因此，对于每个新进程，我们需要为其trapframe分配一块新的内存，这就是为什么这里调用了kalloc()函数。

# kvminithart
为每个CPU设置内核页表，这里并不是启动一个新的线程或者进程，而是为了将CPU上运行的所有线程或进程都能使用相同的内核页表。这样，不管在哪个CPU上运行，所有进程在内核态下看到的内存映射都是一样的，这大大简化了内核代码的编写。

# scheduler()
加载内核页表到satp 寄存器 h/w page table register　硬件页表寄存器


# 为每个进程增加内核页表
改造 proc 的数据结构  加上 kernelpt 这个变量
初始化进程的内核页表  在vm.c中增加方法 proc_kpt_init
在proc.c中的allocproc 中调用(在进程表中找到 未使用的进程 并初始化) 
然后进程的内核页表 映射到 物理地址  需要 procinit  将 kernelpt 映射到  pa 里面 
修改 scheduler() 来加载进程的内核页表satp 寄存器
修改释放进程资源的代码 freeproc 



# 编译器报错知识 

这个错误表明，编译器在试图编译这段代码时找不到函数uvmmap的定义或声明，所以它在提示你是否原本想要使用已经定义的kvmmap函数。在C语言中，函数在被调用之前，需要先声明或定义，否则编译器就不知道这个函数的存在。

cc1是GNU编译器(GCC)的一部分，它是C编译器的实际编译阶段。错误信息cc1: all warnings being treated as errors表示，所有警告（warnings）都被当做错误（errors）来处理，这通常是由于编译器选项-Werror导致的。

关于| ^~~~~~ | kvmmap这部分，^符号指向错误发生的具体位置，kvmmap是编译器推测你可能想要使用的函数名。

要解决这个问题，你需要查看你的代码，确认uvmmap函数是否已经在被调用的位置之前定义或者声明。如果这个函数是你自己定义的，确保其定义或声明的位置正确。如果这是一个库函数或者其他文件的函数，你可能需要包含正确的头文件，或者确认你链接了正确的库。

# 问题一：为什么要给进程添加内核页表有什么好处？
隔离和保护：每个进程拥有自己的内核页表，可以保护进程不受其他进程的影响，因为每个进程只能访问其自己的内存空间。这增加了操作系统的稳定性和安全性。
并发性：如果每个进程都有自己的内核页表，那么在内核模式下，它们可以并发运行在不同的CPU上。

# 如果只是为了给进程添加内核页表，那为什么要将procinit里面的初始化部分移动到allocproc中？
在操作系统中，进程的生命周期开始于创建进程，结束于进程的终止。进程的创建通常涉及到为新进程分配和设置各种资源，比如内存、文件描述符、环境变量等。

如果每个进程都有自己的内核栈，那么最自然的地方来分配和初始化这个内核栈就是在创建新进程的地方，也就是allocproc函数。这样做可以确保在进程的整个生命周期中，内核栈都是存在的，并且可以被适当地回收。

另一方面，procinit可能只会在操作系统启动时运行一次，这是为了初始化进程表，如果内核栈的初始化放在这里，那么所有的进程可能会共享同一个内核栈，这是不合理的，也可能导致各种问题。每个进程应该拥有自己独立的内核栈。

总的来说，这种修改是为了让每个进程拥有自己独立的内核页表和内核栈，从而提高操作系统的并发性和隔离性。